//сделаем то же что и в классовом синтаксисе , теперь с функциями конструкторами

function Test(name, age) {
    this.name = name;
    this.age = age;
}

Test.prototype.getName = function () {
};

//как запилить наследование с использованием функций?

function SuperTest(name, age, city) {
    Test.call(this, name, age)  //эта строчка нужна чтобы не дублировать код и чтобы отследить где именно объект начинает формироваться и где какие свойства заполняются
    //то есть методом call мы заполняем собственные свойства объекта
    //а методом object.create создаем наследование прототипов
    this.city = city
}

//но прототипа нужного не будет, поэтому:

SuperTest.prototype = Object.create(Test.prototype, {
    constructor: {
        value: SuperTest, //конструктор указывает на саму функцию: это позволяет установить связь экземпляра
        //с функцией создавшей этот экз, и если экземпляр оказался в коде там где недоступна функция-создатель, то
        // вдруг нам нужен в этом месте другой экз-р от этой функции, то мы из нашего существующего экземпляра сделаем
        //еще один экземпляр!
    },
    getName: {
        value: function () {
        }
    }
})

let obj = new SuperTest('Hanna', 35, 'Brya')
console.log(obj);
//то есть для функций всегда  нужно будет вызывать call, заполнять все нужные нам свойста, а далее
//переопределять прототип чтобы четко работало
// переопределение делается сразу после объявления функции
//в общем в итоге выполняется все то что делает ключевое слово extends  в классах

let obj2 = new obj.constructor('Yo', 450, 'Minsk')
console.log(obj2);

//мы бы хотели знать экземпляром чего является какой то объект?
console.dir(obj.constructor) //SuperTest - we get name of function which creates this obj

//в JS есть instanceof:
console.log(obj2 instanceof SuperTest) //true
console.log(obj2 instanceof Test) //true
//это экземпляр и того и другого!
//ключевое слово инстанс идет по цепочке [[Prototype]] от ближнего (первого) прототипа до первого совпадения,
// находит и возвращает истину.
//собственные свойства на объекте не проверяются,
//а например сам объект когда мы с ним работаем, проверяет сначала собственные свойства а потом цепочку прототайп
//если мы не знаем какой класс от какого наследуется то только двумя проверками можем узнать
//экземпляром какого класса будет являться объект

//////////Задачка - переписать определение объекта чтобы все получилось и увидеть лог? (тут работа с сеттером и геттером)
//let obj3 = {a: 1}
let obj3 = {}
Object.defineProperty(obj3, 'a', {
    set(value) {
this.a=value
    },
    get() {
return this.a+=1
    },
})
obj3.a=1
console.log(obj3)




//
// if (obj3.a === 1 && obj3.a === 2 && obj3.a === 3) {
//     alert('Bingo!!!!!!')
// }

